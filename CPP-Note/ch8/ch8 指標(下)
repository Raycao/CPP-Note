指標(下):

雙重指標:
「雙重指標」也有人稱為「指標的指標」，其作用為「間接參照」
指標用來儲存變數的記憶體位址，但指標當然也有自己占用的記憶體位址
我們可以用範例: ptrLocation.cpp來稍微再了解一點


總之指標就是幫別人記位址，那其實也可以再用一個指標來幫別的指標記位址
例如要幫int*指標記位址，就必須要用int**來記，例如下:
int **ptr2 = &ptr;
見範例: ptrptr.cpp
所以*(*ptr2 ) == *ptr1 , 而*ptr2 == ptr1



指標與字串:

**重點***: 字元指標可以參考至一個字串常數
例如: char *str = "hello"; 
雖然是char型態，卻指定了字串


而這就是好處，可以直接使用指定運算子將一個字串常數指定給字元指標，
例: str = "world";
範例: ptrChar.cpp


使用一個字串常數時，該字串常數會佔有一個記憶體空間
例如"hello"與"world"都各佔有一塊記憶體空間
所以範例的程式str前後所指向的記憶體位址並不相同
見範例: ptrChar2.cpp


使用陣列的方式宣告字串，則不可以直接使用=指定運算子另外指定字串
可以用字元指標使用陣列，範例: ptrChar3.cpp
擴充至二維的陣列，範例: ptrChar4.cpp

好的，所以你可以有以下兩種方式:
1. char *str1[] = {"professor", "Justin", "etc."}; 
2. char str2[3][10] = {"professor", "Justin", "etc."};

差別在於記憶體是否連續與否
第一種是指標元素指向一個字串常數，所以根據字串常數的記憶體而不同
第二種則是先配置連續的3x10的字元陣列空間連續配置記憶體，再下去填資料
記得要包含空字串'\0'



命令列引數:

程式執行方式在以文字畫面為主的程式中相當常見， 稱之為「命令列引數」（Command-line argument）
再java中會有public statci void main(String[] args)
小括號內就是取命令列的引數

而c++也可以，如果要使用命令列引數，可以如下寫:
int main(int argc, char *argv[]){...}

參數argc是一個整數，它記錄命令列引數的個數，這個數目包括了程式名稱
例如: app hello.c -o  -c project.p
此五個引數便放進第二個參數，char *argv[]中


參考（Reference):
參考（Reference）型態代表了變數或物件的一個別名（Alias）
可以直接取得變數或物件的位址，並間接透過參考型態別名來操作物件
作用類似於指標，但卻不必使用指標語法，例如下:
int var = 10;  // 定義變數
int *ptr = &var; // 定義指標，指向var的位址
int &ref = var;  // 定義參考，代表var變數
最後一行即是參考
注意: 參考一定要初始化!!!! 否則不能通過編譯
參考初始化後就不能改變它所代表的物件，任何指定給參考的值，就相當於指定給原來的物件
範例: ref.cpp


你也可以餐到到一個字面常量，不過要加上const，例: const int &ref = 10;
因為字面常量是不可定址的，但是參考要定址啊，所以她其實會做轉換，例如下:
int tmp = 10;
const int &ref = tmp;

所以如果你沒有加const，就去改變參考的內容，實際上是改變tmp的內容
而非字面常量10，所以根本沒改到ref，所以加上const，明確指示不可以再重新指定值給ref


再來定義指標型態的參考，如此定義: type *&refOfPtr = somePtr;
例子如下:
int var = 10;
int *ptr = &var;
int *&ref = ptr;

