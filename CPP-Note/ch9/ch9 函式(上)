ch9 函式

函式簡介:

函式用來將程式組織為一個小的、獨立的運行單元
一個函式可以接受資料，並運行其中的算法，最後將結果傳回。


C++中函式的組成主要包括四個部份：返回值、函式名稱、參數列與函式主體
前三者被稱為函式宣告或函式原型（Function prototype）
C++中規定函式被呼叫之前，必須先作宣告的動作，否則會出現編譯錯誤


函式原型描述的是函式的介面，通常宣告在一個獨立的表頭檔中
而被含入每一個想要呼叫函式的檔案中
所以我們可以將函示宣告放進標頭檔中，需要的cpp檔案
再include近來即可。
宣告的例子: int pow2(int); int pow(int, int);


表頭檔案被儲存為.h檔案，接著您可以根據函式原型來實作函式主體
在含入表頭檔案時，如果表頭檔案與含入表頭檔的文件在同一個目錄下，那麼就使用雙引號""來包括表頭檔案名稱
如果是標準或專案專屬的表頭檔，例如C++ 的標準表頭檔，那麼則使用角括號<>來括住
在含入表頭檔後，可以直接呼叫所定義的函式，範例: function.cpp




行內函式（Inline function）:

呼叫函式時會需要分配記憶空間因而需要額外的資源負擔
像pow2()這樣的小函式，可以「建議」編譯器將之設定為「行內函式」（Inline function）
如果建議被採納，則該函式會自動在呼叫點展現為程式碼，行內函式建議可以直接定義於表頭檔案中
例如: 
inline int pow2(int); //建議為行內函式
int pow(int, int);


配合表頭檔，實作函式主題，例如下:
inline int pow2(int num) { 
    return num*num; 
} 

因此在標頭檔與實作cpp檔若要做航內涵式，需進行修改
範例: math2.cpp, math2.h




預設引數:

C++允許您使用預設引數，預設引數的使用在一開始的函式原型宣告中進行定義
而之後的函式定義則無需再宣告，範例: defaultParameter.cpp


須注意的是，預設引數其右的參數也都要為預設引數
所以下面的宣告錯誤:
double volumn(double h = 1.0, double w = 1.0, double l);

應改為如下:
double volumn(double l, double w = 1.0, double h = 1.0);


引數的順序也需要注意，若有引數宣告如下:
bool setScreen(int width = 80, int height = 24, char bkcolor = ' ');

如果使用setScreen('R');，這樣的意思代表setScreen('R', 24, ' ');
明顯與預設引數的類型順序不符，並非我們想像的setScreen(80, 24, 'R');
所以正確的使用應該如此: setScreen(, , 'R');



重載函式（Overloaded function）:

功能類似的函式提供了統一的名稱，但是根據參數列個數或型態的不同，而自動呼叫對應的函式
範例: Overload.cpp



變數可視範圍（Scope）:

變數的作用範圍:
「全域變數」（Global variable）、「區域變數」（Local variable）與「區塊變數」（Block variable）


全域變數是指直接宣告在（主）函式之外的變數，這個變數在整個程式之中都「看」得它的存在，而可以呼叫使用
例如下的PI變式全域變數:

const double PI = 3.14159; 

doule area(double r) { 
    return r*r*PI; 
}

int main() { 
    // ..... 
    return 0; 
} 

可以發現main及area函式都可以直接使用PI，雖然很方便
但不建議使用，會有變數的管理問題，生命周期過長，或許記憶體會占用較多


區域變數是指宣告在函式之內的變數，或是宣告在參數列之前的變數
它的可視範圍只在宣告它的函式區塊之中，其它的函式不可以使用該變數
就如同上面例子中，在arae內的r，在area內可以操作
但在main就不能操作到area的r變數。


區塊變數是指宣告在某個陳述區塊之中的變數，例如while迴圈區塊中，或是for迴圈區塊，例如下面的變數i在迴圈結束之後，就會自動消失： 
for(int i = 0; i < 100; i++) 
    // ....


當一可視範圍大的變數與可視範圍小的變數發生同名狀況時，可視範圍小的變數會暫時覆蓋可視範圍大的變數，稱之為「變數覆蓋」
例如:
int i = 10; 
for(int i = 0; i < 100; i++)  {
    // ...
}
cout << i << endl;
最後i顯示依然會是10，這樣的狀況也會發生在痊癒與區域變數發生同名的狀況下


再來介紹static變數，當變數有宣告時加上static限定時
一但變數生成，它就會一直存在記憶體之中，即使函式執行完畢，變數也不會消失
先看範例: staticEx.cpp

雖static變數定義在函式中，且透過for迴圈一次一次呼叫
但每次static變數顯示的值都會累加上去，這也就是剛說的會一直存在的意思
雖然變數一直存在於記憶體，但因為是被宣告在函式之中
算是屬於區域變數，函式之外是沒辦法存取static變數的


extern可以聲明變數會在其它的位置被定義，這個位置可能是在同一份文件之中，或是在其它文件之中
例如在某份文件中定義: double someVar = 1000;
然後我們在使用的程式中寫: extern double someVar;
雖然我們沒在此文件定義someVar，但因為加上extern的原因
所以他會自己去尋找someVar在其它位置或文件中的定義

如果你寫這樣: extern double someVar = 2000，會導致錯誤
這個意思表示你要重新定義，定義找到someVar該位置的值


但必須注意，你必須先找到變數，才可以重新指定值
所以你要這樣寫:
extern double someVar;
someVar = 2000;

